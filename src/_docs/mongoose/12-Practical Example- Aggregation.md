# ‚öôÔ∏è Practical Example: Aggregation in Action with Real Mongoose Schema

---

## üß© Step 1: Define the Schema (E-Commerce Example)

We‚Äôll use a realistic setup:

- `User` ‚Äî customers placing orders
- `Product` ‚Äî items sold
- `Order` ‚Äî transaction record connecting users & products

---

### **User Schema**

```ts
import { Schema, model, Types } from "mongoose";

export interface IUser {
  name: string;
  email: string;
  city: string;
}

const userSchema = new Schema<IUser>({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  city: { type: String, required: true },
});

export const User = model<IUser>("User", userSchema);
```

---

### **Product Schema**

```ts
export interface IProduct {
  name: string;
  category: string;
  price: number; // in rupees
}

const productSchema = new Schema<IProduct>({
  name: { type: String, required: true },
  category: { type: String, required: true },
  price: { type: Number, required: true },
});

export const Product = model<IProduct>("Product", productSchema);
```

---

### **Order Schema**

```ts
export interface IOrder {
  userId: Types.ObjectId;
  productId: Types.ObjectId;
  quantity: number;
  totalAmount: number;
  status: "pending" | "completed" | "cancelled";
  createdAt: Date;
}

const orderSchema = new Schema<IOrder>({
  userId: { type: Schema.Types.ObjectId, ref: "User", required: true },
  productId: { type: Schema.Types.ObjectId, ref: "Product", required: true },
  quantity: { type: Number, required: true },
  totalAmount: { type: Number, required: true },
  status: { type: String, enum: ["pending", "completed", "cancelled"], default: "pending" },
  createdAt: { type: Date, default: Date.now },
});

export const Order = model<IOrder>("Order", orderSchema);
```

---

## üß† Step 2: Insert Sample Data

Example (for local test):

```ts
await User.insertMany([
  { name: "Vipin", email: "vipin@mail.com", city: "Delhi" },
  { name: "Aman", email: "aman@mail.com", city: "Mumbai" },
]);

await Product.insertMany([
  { name: "Phone", category: "Electronics", price: 15000 },
  { name: "Headphones", category: "Electronics", price: 2000 },
  { name: "Shoes", category: "Fashion", price: 3000 },
]);

await Order.insertMany([
  {
    userId: user1._id,
    productId: product1._id,
    quantity: 2,
    totalAmount: 30000,
    status: "completed",
  },
  {
    userId: user2._id,
    productId: product3._id,
    quantity: 1,
    totalAmount: 3000,
    status: "completed",
  },
  {
    userId: user1._id,
    productId: product2._id,
    quantity: 3,
    totalAmount: 6000,
    status: "completed",
  },
]);
```

---

## üîç Step 3: Example 1 ‚Äî Total Revenue by Category

Let‚Äôs analyze total sales grouped by product category.

```ts
const result = await Order.aggregate([
  // 1Ô∏è‚É£ Join with Product collection
  {
    $lookup: {
      from: "products", // collection name in lowercase + plural
      localField: "productId",
      foreignField: "_id",
      as: "product",
    },
  },

  // 2Ô∏è‚É£ Flatten the joined product array
  { $unwind: "$product" },

  // 3Ô∏è‚É£ Only completed orders
  { $match: { status: "completed" } },

  // 4Ô∏è‚É£ Group by category
  {
    $group: {
      _id: "$product.category",
      totalRevenue: { $sum: "$totalAmount" },
      totalQuantity: { $sum: "$quantity" },
      avgOrderValue: { $avg: "$totalAmount" },
    },
  },

  // 5Ô∏è‚É£ Sort by highest revenue
  { $sort: { totalRevenue: -1 } },
]);
```

---

### ‚úÖ Output Example

```json
[
  {
    "_id": "Electronics",
    "totalRevenue": 36000,
    "totalQuantity": 5,
    "avgOrderValue": 12000
  },
  {
    "_id": "Fashion",
    "totalRevenue": 3000,
    "totalQuantity": 1,
    "avgOrderValue": 3000
  }
]
```

---

### üß© Stage-by-Stage Breakdown

| Stage     | Operation                    | What It Does                       |
| --------- | ---------------------------- | ---------------------------------- |
| `$lookup` | Join `Order` ‚Üî `Product`    | Bring product info into each order |
| `$unwind` | Flatten product array        | One order per document             |
| `$match`  | Filter only completed orders | Clean data                         |
| `$group`  | Group by category            | Aggregate sales data               |
| `$sort`   | Sort high to low revenue     | Ranking for dashboard              |

‚úÖ This is the backbone for dashboards ‚Äî ‚ÄúRevenue by Category‚Äù.

---

## ‚öôÔ∏è Step 4: Example 2 ‚Äî Top Customers by Total Spending

Now let‚Äôs find the **top customers** by how much they‚Äôve spent.

```ts
const topCustomers = await Order.aggregate([
  // Join with User data
  {
    $lookup: {
      from: "users",
      localField: "userId",
      foreignField: "_id",
      as: "user",
    },
  },
  { $unwind: "$user" },

  // Only completed orders
  { $match: { status: "completed" } },

  // Group by user
  {
    $group: {
      _id: "$user._id",
      name: { $first: "$user.name" },
      email: { $first: "$user.email" },
      totalSpent: { $sum: "$totalAmount" },
      totalOrders: { $sum: 1 },
    },
  },

  // Sort by totalSpent
  { $sort: { totalSpent: -1 } },

  // Limit top 5
  { $limit: 5 },
]);
```

---

### ‚úÖ Output Example

```json
[
  {
    "_id": "66f...",
    "name": "Vipin",
    "email": "vipin@mail.com",
    "totalSpent": 36000,
    "totalOrders": 2
  },
  {
    "_id": "66f...",
    "name": "Aman",
    "email": "aman@mail.com",
    "totalSpent": 3000,
    "totalOrders": 1
  }
]
```

---

### üß© Stage Breakdown

| Stage     | Description                       |
| --------- | --------------------------------- |
| `$lookup` | Join orders with users            |
| `$unwind` | Flatten user array                |
| `$match`  | Keep only completed orders        |
| `$group`  | Aggregate total spending per user |
| `$sort`   | Rank users by spending            |
| `$limit`  | Take top 5                        |

‚úÖ This query is great for analytics dashboards: ‚ÄúTop Customers by Revenue‚Äù.

---

## üßÆ Step 5: Example 3 ‚Äî Daily Revenue Trend (Time Series)

```ts
const dailySales = await Order.aggregate([
  { $match: { status: "completed" } },
  {
    $group: {
      _id: {
        date: {
          $dateToString: { format: "%Y-%m-%d", date: "$createdAt" },
        },
      },
      totalRevenue: { $sum: "$totalAmount" },
      ordersCount: { $sum: 1 },
    },
  },
  { $sort: { "_id.date": 1 } },
]);
```

‚úÖ Output Example:

```json
[
  { "_id": { "date": "2025-10-01" }, "totalRevenue": 15000, "ordersCount": 2 },
  { "_id": { "date": "2025-10-02" }, "totalRevenue": 18000, "ordersCount": 3 }
]
```

‚úÖ Use this for charts like ‚ÄúRevenue Over Time‚Äù or line graphs.

---

## ‚ö° Step 6: Example 4 ‚Äî `$facet` Dashboard (All-in-One)

Now combine all insights into one **dashboard query**:

```ts
const dashboard = await Order.aggregate([
  { $match: { status: "completed" } },
  {
    $facet: {
      totalRevenue: [{ $group: { _id: null, total: { $sum: "$totalAmount" } } }],
      topCategories: [
        {
          $lookup: {
            from: "products",
            localField: "productId",
            foreignField: "_id",
            as: "product",
          },
        },
        { $unwind: "$product" },
        {
          $group: {
            _id: "$product.category",
            totalRevenue: { $sum: "$totalAmount" },
          },
        },
        { $sort: { totalRevenue: -1 } },
        { $limit: 3 },
      ],
      dailySales: [
        {
          $group: {
            _id: {
              $dateToString: { format: "%Y-%m-%d", date: "$createdAt" },
            },
            totalRevenue: { $sum: "$totalAmount" },
          },
        },
        { $sort: { _id: 1 } },
      ],
    },
  },
]);
```

‚úÖ Returns a **complete analytics payload** for a dashboard ‚Äî
**total revenue**, **top categories**, **daily trend** ‚Äî all in one DB hit.

---

### ‚úÖ Example Output

```json
[
  {
    "totalRevenue": [{ "total": 39000 }],
    "topCategories": [
      { "_id": "Electronics", "totalRevenue": 36000 },
      { "_id": "Fashion", "totalRevenue": 3000 }
    ],
    "dailySales": [
      { "_id": "2025-10-01", "totalRevenue": 15000 },
      { "_id": "2025-10-02", "totalRevenue": 24000 }
    ]
  }
]
```

---

## üß† Step 7: Key Insights

| Concept    | Description                              |
| ---------- | ---------------------------------------- |
| `$lookup`  | Joins other collections (like SQL joins) |
| `$unwind`  | Flattens array fields after lookup       |
| `$match`   | Filters docs before aggregation          |
| `$group`   | Performs sums, counts, averages          |
| `$facet`   | Parallel pipelines (like subqueries)     |
| `$sort`    | Orders result efficiently                |
| `$project` | Shapes the final output                  |

---

## üß† Step 8: Performance Tips for Aggregation

‚úÖ Use `$match` early ‚Üí filter first
‚úÖ Use `$project` early ‚Üí reduce document size
‚úÖ Index fields used in `$match` or `$lookup`
‚úÖ Cache results using Redis if reused often
‚úÖ Avoid `$lookup` on massive collections unless indexed
‚úÖ For frequent analytics ‚Äî store denormalized ‚Äúsummary‚Äù data

---

## üß† Summary

| Aggregation Type | Use Case                           |
| ---------------- | ---------------------------------- |
| Category revenue | Dashboard category summary         |
| Top customers    | Loyalty & ranking features         |
| Daily revenue    | Charts and time-series             |
| `$facet`         | Full analytics report in one query |

---

## üöÄ Coming Next: **Point 12 ‚Äì Schema Inheritance & Discriminators**

We‚Äôll cover:

- What discriminators are and why they‚Äôre powerful
- How to use **base schemas** for shared fields
- Example: `User ‚Üí Admin / Customer` inheritance
- Querying across discriminators
- Real-world examples with role-based systems

---

Excellent question üëè ‚Äî this little piece ‚Äî

```ts
as: "product";
```

inside your `$lookup` stage ‚Äî is _super_ important to understand clearly.

It controls **how the joined documents are stored** after MongoDB performs the lookup (join).

Let‚Äôs break it down in simple and deep detail üëá

---

# üß© `$lookup` Stage ‚Äî Deep Explanation

The `$lookup` stage in MongoDB‚Äôs aggregation pipeline is like a **JOIN** in SQL.
It lets you pull data from another collection and combine it with your current one.

---

### General Structure of `$lookup`

```ts
{
  $lookup: {
    from: "<foreign_collection_name>",
    localField: "<field_in_current_collection>",
    foreignField: "<field_in_foreign_collection>",
    as: "<output_field_name>"
  }
}
```

---

### Explanation of Each Property

| Property         | Description                                                                                                         |
| ---------------- | ------------------------------------------------------------------------------------------------------------------- |
| **from**         | The name of the _other collection_ you want to join (must match the MongoDB collection name, _not_ the model name). |
| **localField**   | The field in the current collection (e.g., `productId` in the `Order` collection).                                  |
| **foreignField** | The field in the foreign collection to match against (usually `_id` in the `Product` collection).                   |
| **as**           | The name of the new array field that will contain the _joined data_.                                                |

---

### Example Context

We‚Äôre in the **`Order`** collection, and we want to **join product info** from the **`Product`** collection.

```ts
await Order.aggregate([
  {
    $lookup: {
      from: "products",
      localField: "productId",
      foreignField: "_id",
      as: "product",
    },
  },
]);
```

---

### What Happens Internally

MongoDB performs this:

> ‚ÄúFor every document in the `orders` collection,
> find the documents in `products` where
> `products._id === orders.productId`.‚Äù

Then, it adds a **new array field** called `product` to each order.

---

### üß† Example Before `$lookup`

**Order document:**

```json
{
  "_id": "O1",
  "userId": "U1",
  "productId": "P1",
  "quantity": 2,
  "totalAmount": 30000
}
```

**Product document:**

```json
{
  "_id": "P1",
  "name": "Phone",
  "category": "Electronics",
  "price": 15000
}
```

---

### üß© After `$lookup` (Before `$unwind`)

The resulting document looks like this üëá

```json
{
  "_id": "O1",
  "userId": "U1",
  "productId": "P1",
  "quantity": 2,
  "totalAmount": 30000,
  "product": [
    {
      "_id": "P1",
      "name": "Phone",
      "category": "Electronics",
      "price": 15000
    }
  ]
}
```

üí° Notice:

- The joined data from `products` is stored inside a **new array field** named `"product"`.
- This field name comes **exactly** from `as: "product"`.

---

### ‚öôÔ∏è Why It‚Äôs an Array

Because MongoDB allows **1-to-many relationships**, the `$lookup` result is **always an array** (even if there‚Äôs only one matching document).

If `productId` matched multiple products (in theory), all of them would be inside the `"product"` array.

---

### üîß Flattening the Result with `$unwind`

Since we often know there‚Äôs only **one matching product**, we use `$unwind` to **flatten** that array.

```ts
{
  $unwind: "$product";
}
```

Result:

```json
{
  "_id": "O1",
  "userId": "U1",
  "productId": "P1",
  "quantity": 2,
  "totalAmount": 30000,
  "product": {
    "_id": "P1",
    "name": "Phone",
    "category": "Electronics",
    "price": 15000
  }
}
```

‚úÖ Now, `product` is an **object**, not an array.
‚úÖ Much easier to use in further aggregation stages or API responses.

---

### ‚ö° Summary of `$lookup` Properties

| Field          | Example Value | Description                                             |
| -------------- | ------------- | ------------------------------------------------------- |
| `from`         | `"products"`  | Collection to join                                      |
| `localField`   | `"productId"` | Field in current (`orders`) collection                  |
| `foreignField` | `"_id"`       | Field in the `products` collection                      |
| `as`           | `"product"`   | Name of new array field containing the joined documents |

---

### üß† SQL Analogy

Think of `$lookup` as this SQL query:

```sql
SELECT *
FROM orders o
LEFT JOIN products p
ON o.productId = p._id;
```

Here, `as: "product"` ‚Üí means ‚Üí store all `p.*` (joined data) in a field named `"product"` inside each order document.

---

### üí° Best Practices

‚úÖ Always choose a clear `as` name
‚Üí e.g., `"product"`, `"userInfo"`, `"categoryDetails"`

‚úÖ Use `$unwind` after `$lookup` if it‚Äôs 1:1 relation
‚úÖ Index the `foreignField` for faster join performance
‚úÖ Keep `from` name lowercase + plural (matches MongoDB collection naming)

---

### üßÆ Advanced Example with Multiple `$lookup`s

You can chain multiple joins:

```ts
await Order.aggregate([
  {
    $lookup: {
      from: "users",
      localField: "userId",
      foreignField: "_id",
      as: "user",
    },
  },
  { $unwind: "$user" },
  {
    $lookup: {
      from: "products",
      localField: "productId",
      foreignField: "_id",
      as: "product",
    },
  },
  { $unwind: "$product" },
  { $project: { "user.name": 1, "product.name": 1, totalAmount: 1 } },
]);
```

‚úÖ Adds both user and product data inside each order document.

---

### ‚öôÔ∏è Summary Visualization

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        orders              ‚îÇ
‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ
‚îÇ _id: O1                    ‚îÇ
‚îÇ productId: P1              ‚îÇ
‚îÇ ...                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚îÇ $lookup (join)
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        products            ‚îÇ
‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ
‚îÇ _id: P1                    ‚îÇ
‚îÇ name: "Phone"              ‚îÇ
‚îÇ category: "Electronics"    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Result:
{
  ...orderFields,
  product: [ {...productFields} ]
}
```

---

## Ex-lookup

inside your `$lookup` stage ‚Äî is _super_ important to understand clearly.

It controls **how the joined documents are stored** after MongoDB performs the lookup (join).

Let‚Äôs break it down in simple and deep detail üëá

---

# üß© `$lookup` Stage ‚Äî Deep Explanation

The `$lookup` stage in MongoDB‚Äôs aggregation pipeline is like a **JOIN** in SQL.
It lets you pull data from another collection and combine it with your current one.

---

### General Structure of `$lookup`

```ts
{
  $lookup: {
    from: "<foreign_collection_name>",
    localField: "<field_in_current_collection>",
    foreignField: "<field_in_foreign_collection>",
    as: "<output_field_name>"
  }
}
```

---

### Explanation of Each Property

| Property         | Description                                                                                                         |
| ---------------- | ------------------------------------------------------------------------------------------------------------------- |
| **from**         | The name of the _other collection_ you want to join (must match the MongoDB collection name, _not_ the model name). |
| **localField**   | The field in the current collection (e.g., `productId` in the `Order` collection).                                  |
| **foreignField** | The field in the foreign collection to match against (usually `_id` in the `Product` collection).                   |
| **as**           | The name of the new array field that will contain the _joined data_.                                                |

---

### Example Context

We‚Äôre in the **`Order`** collection, and we want to **join product info** from the **`Product`** collection.

```ts
await Order.aggregate([
  {
    $lookup: {
      from: "products",
      localField: "productId",
      foreignField: "_id",
      as: "product",
    },
  },
]);
```

---

### What Happens Internally

MongoDB performs this:

> ‚ÄúFor every document in the `orders` collection,
> find the documents in `products` where
> `products._id === orders.productId`.‚Äù

Then, it adds a **new array field** called `product` to each order.

---

### üß† Example Before `$lookup`

**Order document:**

```json
{
  "_id": "O1",
  "userId": "U1",
  "productId": "P1",
  "quantity": 2,
  "totalAmount": 30000
}
```

**Product document:**

```json
{
  "_id": "P1",
  "name": "Phone",
  "category": "Electronics",
  "price": 15000
}
```

---

### üß© After `$lookup` (Before `$unwind`)

The resulting document looks like this üëá

```json
{
  "_id": "O1",
  "userId": "U1",
  "productId": "P1",
  "quantity": 2,
  "totalAmount": 30000,
  "product": [
    {
      "_id": "P1",
      "name": "Phone",
      "category": "Electronics",
      "price": 15000
    }
  ]
}
```

üí° Notice:

- The joined data from `products` is stored inside a **new array field** named `"product"`.
- This field name comes **exactly** from `as: "product"`.

---

### ‚öôÔ∏è Why It‚Äôs an Array

Because MongoDB allows **1-to-many relationships**, the `$lookup` result is **always an array** (even if there‚Äôs only one matching document).

If `productId` matched multiple products (in theory), all of them would be inside the `"product"` array.

---

### üîß Flattening the Result with `$unwind`

Since we often know there‚Äôs only **one matching product**, we use `$unwind` to **flatten** that array.

```ts
{
  $unwind: "$product";
}
```

Result:

```json
{
  "_id": "O1",
  "userId": "U1",
  "productId": "P1",
  "quantity": 2,
  "totalAmount": 30000,
  "product": {
    "_id": "P1",
    "name": "Phone",
    "category": "Electronics",
    "price": 15000
  }
}
```

‚úÖ Now, `product` is an **object**, not an array.
‚úÖ Much easier to use in further aggregation stages or API responses.

---

### ‚ö° Summary of `$lookup` Properties

| Field          | Example Value | Description                                             |
| -------------- | ------------- | ------------------------------------------------------- |
| `from`         | `"products"`  | Collection to join                                      |
| `localField`   | `"productId"` | Field in current (`orders`) collection                  |
| `foreignField` | `"_id"`       | Field in the `products` collection                      |
| `as`           | `"product"`   | Name of new array field containing the joined documents |

---

### üß† SQL Analogy

Think of `$lookup` as this SQL query:

```sql
SELECT *
FROM orders o
LEFT JOIN products p
ON o.productId = p._id;
```

Here, `as: "product"` ‚Üí means ‚Üí store all `p.*` (joined data) in a field named `"product"` inside each order document.

---

### üí° Best Practices

‚úÖ Always choose a clear `as` name
‚Üí e.g., `"product"`, `"userInfo"`, `"categoryDetails"`

‚úÖ Use `$unwind` after `$lookup` if it‚Äôs 1:1 relation
‚úÖ Index the `foreignField` for faster join performance
‚úÖ Keep `from` name lowercase + plural (matches MongoDB collection naming)

---

### üßÆ Advanced Example with Multiple `$lookup`s

You can chain multiple joins:

```ts
await Order.aggregate([
  {
    $lookup: {
      from: "users",
      localField: "userId",
      foreignField: "_id",
      as: "user",
    },
  },
  { $unwind: "$user" },
  {
    $lookup: {
      from: "products",
      localField: "productId",
      foreignField: "_id",
      as: "product",
    },
  },
  { $unwind: "$product" },
  { $project: { "user.name": 1, "product.name": 1, totalAmount: 1 } },
]);
```

‚úÖ Adds both user and product data inside each order document.

---

### ‚öôÔ∏è Summary Visualization

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        orders              ‚îÇ
‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ
‚îÇ _id: O1                    ‚îÇ
‚îÇ productId: P1              ‚îÇ
‚îÇ ...                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚îÇ $lookup (join)
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        products            ‚îÇ
‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ
‚îÇ _id: P1                    ‚îÇ
‚îÇ name: "Phone"              ‚îÇ
‚îÇ category: "Electronics"    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Result:
{
  ...orderFields,
  product: [ {...productFields} ]
}
```

---
